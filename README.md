## User Stories

The following **required** functionality is completed:

- The code works as specified in the challenge and there is a good ReadMe file.
- Code satisfies both the functional and non-functional requirements.
- ReadMe file provides information to build and run the app.
- If there are shortcomings, those are highlighted in the ReadMe file.
- The code uses the appropriate set of data structures and algorithms.
- The Big-O complexity is taken into account.
- The data structures are appropriate for the task at hand.
- The code demonstrates good separation of concerns.
- There is a good layered architecture and responsibilities are not leaked across layers.
- The project layout reflects this layering/separation of concerns and it is intuitive to navigate.
- The abstractions are easy to understand and appropriately designed.
- The code demonstrates correct use of engineering trade-offs and is not “over-engineered”.
- Things that are simple are kept simple.
- There is no extra requirements invented other than those that are provided.
- The code demonstrates good use of single source of truth.
- When you need to change something, you can change it in one place most of the time and it is sufficient.
- The code demonstrates use of DRY principles:
- Refrains from copy & paste code unless it is necessary to simplify things or there is not a good chance to create a better abstraction due to lack of examples.
- The code demonstrates properly designed error handling.
- There is error handling.
- Makes a distinction between engineering errors (assertions) vs. user errors (proper messaging/logging) vs. system errors (fail fast if non-recoverable) and handles each properly.
- Errors do not leave the system in an unstable/unknown state.
- The code is readable.
- Good naming that reflects the semantic meaning.
- No dead code that confuses people.
- Cyclomatic complexity is not high - not too much nested logic.
- Good use of commenting - relies on easy-to-understand code and documents only complex or tricky areas.
- The code is testable.
- Refactored so that you can write isolated unit tests. Making the right trade-offs are important. I.e. if refactoring adds complexity, it needs to be balanced.
- Classes & methods are not trying to do too many things. (Single-responsibility principle)
- Pragmatic - if the test is not really adding value on top of what compiler already does, then it is not necessary.
- Uses mocks appropriately. Refrains from having too many dependencies and those dependencies can be injected.
- The tests assert one thing (to the extent possible) at a time.
- The code demonstrates platform proficiency.
- For a given language/platform, idiomatic programming practices are applied. (E.g. not writing Swift code like Objective C code).
- The platform provided APIs used appropriately. The code does not reimplement things that are already provided by the platform.
- The platform behavior is understood. For example, application lifecycle events, memory management, thread management…
- The code demonstrates good judgement when bringing in 3rd party dependencies.
- The trivial functionality is not imported as a 3rd party dependency. (i.e. do not use a framework to impress us, use it only if it is genuinely required in the challenge.)
- If a 3rd party dependency is chosen, demonstration of its idiomatic usage and deep understanding is required. (i.e. do not use a framework that you don’t know well.) 
- ReadMe reflects the decisions that lead to the choice.
- Please do not use the Cocoa SoundCloud SDK as it is deprecated and instead used the Web API endpoints.

The following **optional** features are implemented:

- [ ]

## Video Walkthrough

## Submission Steps:
We review code challenges anonymously. Help us out and please remove all reference to your name from comments and git logs.
Please DO NOT share your code on Github, Bitbucket etc.
Please DO NOT share the provided client ID.
Please add a README with instructions/notes on your submission.